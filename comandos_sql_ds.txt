
************************************************************
************ CURSO DE SQL PARA DATA SCIENCE ****************
************************************************************

select
	4 as ColunaNum;

# Exibe o número 4 e muda o nome da coluna para "ColunaNum".

============================================================

select
	4 as Coluna1,
	10 as Coluna2;

# Exibe o número 4 na "Coluna1" e 10 na "Coluna2".

=============================================================

select
	'Conrado' as Nome,		# Cria a coluna "Nome" com o valor "Conrado"
	43 as Idade, 	# Cria a coluna "Idade" com valor "43"
	1.82 as Peso, 	# Cria a coluna "Peso" com valor "1.82"
	5 * 3 as ColunaResult;		# Cria a coluna "Multiplicacao" com o resultado de 5*3 = 15

==============================================================

select
  name
from
  e_commerce.categories;
  
# Exibe todos nomes da coluna "name" do banco de dados "e_commerce" e tabela "categories".

===============================================================

select
	created_at,
	status
from
	e_commerce.orders;
	
# Exibi os dados das colunas "creat_at" e "status" do bd "e_commerce" da tabela "orders".

================================================================

select
	created_at as DataPedido,
	status as Situacao
from
	e_commerce.orders;
	
/*
Exibi os dados da coluna "creat_at" alterando o nome da coluna para "DataPedido",
exibi os dados da coluna "status" alterando o nome da coluna para "Situacao" do
bd "e_commerce" da tabela "orders".
*/

================================================================

select
	id as ID,
from
	e_commerce.items
limit
	5;

# Limita a coluna "id" na quantidade de linhas para 5 da tabela "items".

=================================================================

select
	distinct state as UF,
from
	e_commerce.customers;
	
# Exibe somente os valores únicos da tabela "state" (valores iguais não repetem).

=================================================================

select
	distinct state as UF,
from
	e_commerce.customers
limit
	3;
	
=================================================================

select
	count(distinct state),
from
	e_commerce.customers
	
# Conta a quantidade de regitros da coluna "state".

=================================================================

select
	count(distinct state) as QTDADE_UF,
from
	e_commerce.customers
	
# Conta a quantidade de regitros da coluna "state" renomeando a coluna para "QTDADE_UF"

=================================================================

**** OPERADORES ****

	Lógicos:
NOT --> não
AND --> e
OR --> ou

	Aritméticos:
+ --> soma
- --> subtraçãp
* --> multiplicação
/ --> divisão

	Condição "IS":
IS NULL --> é nulo
IS TRUE --> é verdadeiro
IS FALSE --> é false

	Comparação:
= --> igual
!= --> diferente
> --> maior
< --> menor
<= --> menor ou igual
>= --> maior ou igual
BETWEEN --> entre
LIKE --> como
IN --> está contido

=========================================================

select
	1 = 1,  # true
	5 > 10, # false
	6 < 8,  # true
	2 != 2,  # false
	25 >= 25,  # true
	15 >= 20,  # false
	15 <= 20;  # true

=========================================================

select
	10 between 8 and 12,  # true
	2 between 4 and 9,  # false
	-13 between 0 and 100,	# false
	25 between -0 and -100,	# false
	-5 between -7 and -1,	#true
	-5 between -1 and -7;	#false

=========================================================

select
	*							# Mostra todas as colunas com o filtro "products" entre 30 e 80
from
	e_commerce.products
where
	price between 30 and 80;
	
	-- OU --
	
select
	price						# Mostra somente a coluna "price" com o filtro "products" entre 30 e 80
from
	e_commerce.products
where
	price between 30 and 80;

========================================================

select
	*
from
	e_commerce.customers
where
  first_name like 'Mariana';
  
# Tras todas colunas que tenha no filtro "first_name" a palavra "Mariana".


	--	OU	--
	
select
	*
from
	e_commerce.customers
where
  first_name like 'M%';
  
# Tras todas colunas que tenha no filtro "first_name" a palavra que começa com "M".

	--	OU	--
	
select
	*
from
	e_commerce.customers
where
  first_name like 'r%';
  
# Tras todas colunas que tenha no filtro "first_name" a palavra que termina com "r".

	--	OU	--
	
select
	*
from
	e_commerce.customers
where
  first_name like 'J%' and first_name like '%r';
  
# Tras todas colunas que tenha no filtro "first_name" a palavra que começa com "J" e termina com "r".

	--	OU	--

select
	*
from
	e_commerce.customers
where
  first_name like 'J%r';
  
# Tras todas colunas que tenha no filtro "first_name" a palavra que começa com "J" e termina com "r".


	--	OU	--

select
  customers
from
  e_commerce.customers
where
  first_name like 'Mariana'

========================================================

select
  *
from
  e_commerce.products
where
  price in(10, 11, 15)
  
# Tras todas colunas da tabela "products" quando contiver os valores "10, 11 e 15" na tabela "price".

	--	OU --
	
select
  *
from
  e_commerce.customers
where
  state in('Acre', 'Ceará')
  
# # Tras todas colunas da tabela "customers" quando contiver os valores "Acre" e "Ceará" na tabela "state".

========================================================

# COMANDO "NULL" e "NOT NULL"

select
	*
from
	e_commerce.customers
where street in null;

# Tras todas colunas da tabela "costumers" que tenha campos nulos da coluna "street".

	--	OU--
	
select
	*
from
	e_commerce.customers
where street in not null;

# Tras todas colunas da tabela "costumers" em que os campos da coluna "street" NÃO sejam nulos.


	--	OU	--
	
select
  *
from
  e_commerce.customers
where first_name like 'M%' and street is null;

=========================================================

select
  *
from
  e_commerce.customers
where
  street is not null and email is not null;
  
=========================================================
  
# COMANDO "TRUE", "FALSE", "IS NOT TRUE" (FALSE) e "IS NOT FALSE" (TRUE)

select
	*
from
	bigquery-public-data.chicago_crime.crime
where
	domestic is true;

# Tras todos valores "true" da coluna "crime" da tabela "chicago_crime" do banco de dados "bigquery-public-data".

##### ALIAS ######

# Altera o nome da coluna temporariamente

select
	id as Identificacao,first_name as PrimeiroNome 
from
	e_commerce.customers;

--------------------
	
select
	id as Identificador,
	total_price as ValorTotal
from
	e_commerce.items
	

------------------

select
  p.name as NomeProduto,
  c.name as NomeCategoria
from
  e_commerce.products as p
join
  e_commerce.categories as c
on
  p.category_id = c.id;
  
--------------------

#### COMANDO WHERE ####

select
	quantity
from
	e_commerce.items
where quantity = 1;

---------------------

select
	order_id as PEDIDO, quantity as QTDADE
from
	e_commerce.items
where quantity = 2;

---------------------

select
	customers
from
	e_commerce.customers
where
	state like 'Bahia' and email is not null;
	
---------------------

select
	first_name as PrimeiroNome,last_name as Sobrenome, email as E_Mail,
from
	e_commerce.customers
where
	state like 'Bahia' and first_name like 'Ana' and email is not null;
	
---------------------------------------

select
	first_name as PrimeiroNome,last_name as Sobrenome, email as E_Mail,
from
	e_commerce.customers
where
	state = 'Bahia' and first_name = 'Ana' and email is not null;

---------------------------------------

select
	*
from
	e_commerce.customers
where
	(state = 'Bahia' or state = 'Ceará') and email is not null;
	
# Se não colocar parenteses, a condição fica errada. Após o "or", vira a segunda condição.

#### COMANDO CASE ####

select
	id, name,
case
	when name = 'Cosméticos e Perfumaria' then 'Sim, é Cosmético e perfumaria'
end as MENSAGEM
from e_commerce.categories

-----------------------------------------

select
	id, name,
case
	when name = 'Cosméticos e Perfumaria' then 'SIM, É COSMÉTICOS E PERFUMARIA'
	when name = 'Esporte e Lazer' then 'SIM, É LIVROS'
	else 'Filtro não encontrado'
end as MENSAGEM
from e_commerce.categories

------------------------------------------

select
	id, name,
	case
		when id between 0 and 5 then 'Primeiro verdadeiro'
		when id between 3 and 5 then 'Segundo verdadeiro'
		when id between 3 and 7 then 'Terceiro verdadeiro'
	end as CASE_2
from bigquery-public-data.thelook_ecommerce.distribution_centers;

--------------------------------------------

#### COMANDO IF ####

select
	id,	name,
	if (name = 'Cosméticos e Perfumaria', 'SIM, É COSMÉTICOS E PERFUMARIA',
	if (name = 'Livros', 'SIM, É LIVROS', 'Opção não encontrada')) as CASE1
from e_commerce.categories;

---------------------------------------------

#### COMANDO COALESCE ####

select
	id,
	first_name,
	additionals,
	coalesce (additionals, 'COMPLEMENTO NULO') as COMPLEMENTO
from
	e_commerce.customers
limit 10;


------------------------------------------------

COMANDOS "GROUP BY" E "ORDER BY"

select
	distinct status,
from
	bigquery-public-data.thelook_ecommerce.orders
	limit 10;
	
	--	OU	--

select
	status,
from
	bigquery-public-data.thelook_ecommerce.orders
group by
	status;

	--	OU	--
	
select
	status,
from
	bigquery-public-data.thelook_ecommerce.orders
group by
	1;
	
# O número "1" refere-se a primeira coluna.

-----------------------------

select
	count(distinct order_id) as NUMERO_PEDIDOS,
	date(created_at) as DIA
from
	bigquery-public-data.thelook_ecommerce.orders
group by DIA;

-----------------------------

select
	count(distinct order_id) as NUMERO_PEDIDOS,
	date(created_at) as DIA
from
	bigquery-public-data.thelook_ecommerce.orders
group by DIA
order by DIA;

-------------------------------------------

select
	count(distinct order_id) as NUMERO_PEDIDOS,
	date(created_at) as DIA
from
	bigquery-public-data.thelook_ecommerce.orders
group by DIA
# order by DIA asc
order by DIA desc
limit 30;

# "asc" --> Ordena de forma crescente
# "desc" --> Ordema de forma decrescente

--------------------------------------------

#### COMANDO JOIN ####

# A função do join é juntar informações que estão em duas ou mais tabelas diferentes. Juntamente com o "JOIN",
# devemos usar o parâmetro "ON", pois esse parâmetro possibilita relacionar tabelas pela chave.

select
	o.order_id,
	o.user_id,
	num_of_item,
	i.order_id,
	i.user_id,
round(sum(sale_price), 2) as receita 
from bigquery-public-data.thelook_ecommerce.orders as o
join bigquery-public-data.thelook_ecommerce.order_items as i on o.order_id = i.order_id
group by 1, 2, 3, 4, 5
order by receita desc;

# Função round --> Arredondamento de float


------------------------------------------------

**************  EXERCÍCIOS ****************

1) Utilize o dataset público “thelook_ecommerce”, que está presente no projeto “bigquery-public-data” para
trazer o identificador único dos usuários, o primeiro nome, email e idade, ordernados pela data de criação
do cadastro.

select
  id,
  first_name,
  email,
  age,
from
  bigquery-public-data.thelook_ecommerce.users
order by created_at;

2) No mesmo dataset do exercício anterior, extraia os pedidos que tenham status “Shipped” ou “Processing”.

select
  order_id,
  status,
from
  bigquery-public-data.thelook_ecommerce.orders
where
  status in ('Shipped', 'Processing')
order by order_id;

3) Considerando o mesmo exercício anterior, traga os pedidos que foram criados no dia “2022-04-05” e
ao mesmo tempo, tenham status “Cancelled”.

select
  order_id,
  status,
from
  bigquery-public-data.thelook_ecommerce.orders
where
  status = 'Cancelled' and date(created_at) = '2022-04-05';

4) O time de marketing deseja fazer uma campanha em um país específico, com o mesmo dataset dos itens
anteriores. Para isso, eles te pedem os e-mails de todos os clientes que moram no Brasil.

select
  email,
  country,
from
  bigquery-public-data.thelook_ecommerce.users
where
  email is not null and country = 'Brasil';

5) No mesmo dataset anterior, traga o nome dos usuários e o id de seus pedidos.

select
  order_id,
  first_name,
from bigquery-public-data.thelook_ecommerce.users as u
join bigquery-public-data.thelook_ecommerce.orders as o on u.id = o.user_id;


6) Vá ao dataset público “baseball” e na tabela “schedules” traga os identificadores únicos, o
nome do time da casa e o nome do time de fora de casa dos jogos em que a duração foi maior ou
igual a 250 minutos e menos de 25 mil espectadores.

select
  gameId,
  seasonId,
  homeTeamId,
  awayTeamId
  homeTeamName,
  awayTeamName,
  attendance,
  duration_minutes,
from
  bigquery-public-data.baseball.schedules
where 
  duration_minutes >= 250 and attendance < 25000;

7) No mesmo dataset e tabela, retorne os jogos que começaram entre maio e junho de 2016.

select
  startTime,
  homeTeamName,
  awayTeamName,
from
  bigquery-public-data.baseball.schedules
where startTime >= '2016-05-01' and startTime <= '2016-06-01'
# where date(startTime) between '2016-05-01' and '2016-06-01'
# where startTime between '2016-05-01 00:00:00' and '2016-06-01 23:59:59'
order by startTime;

8) DESAFIO: No mesmo dataset anterior, descubra o nome dos times que tenham somente 6
caracteres, usando o like. Retorne de forma única.

select
	distinct homeTeamName
from
	bigquery-public-data.baseball.schedules
where
	homeTeamName like '______';
	
	
#### FUNÇÃO COUNT, MAX, MIN E AVG ####

# count --> mostra a quantidade de registros de uma coluna

select
	count(id),
from
	bigquery-public-data.thelook_ecommerce.users;

------------------------------------

select
	count(distinct id) as QTDE_USUARIOS_UNICOS
from
	bigquery-public-data.thelook_ecommerce.users;
	
------------------------------------

select
	count(status),
from
	bigquery-public-data.thelook_ecommerce.orders;

------------------------------------

select
	count(status) as QTDE_STATUS,
from
	bigquery-public-data.thelook_ecommerce.orders;

------------------------------------

select
  date(created_at) as DIA,
  count(orders_id) as QTDE_PEDIDO,
from
  bigquery-public-data.thelook_ecommerce.orders
group by DIA
order by DIA desc;

------------------------------------

select
  extract(created_at) as DIA,
  count(order_id) as QTDE_PEDIDO,
from
  bigquery-public-data.thelook_ecommerce.orders
group by DIA
order by DIA desc;

------------------------------------

select
  extract(year FROM created_at) as ANO,
  count(distinct order_id) as QTDE_PEDIDO,
from
  bigquery-public-data.thelook_ecommerce.orders
group by ANO
order by ANO desc;

------------------------------------

select
  max(retail_price) as PRECO_MAXIMO_VAREJO,
from
  bigquery-public-data.thelook_ecommerce.products;
  
# Mostra o valor máximo do item da coluna "retail_price"

------------------------------------

select
  min(retail_price) as PRECO_MINIMO_VAREJO,
from
  bigquery-public-data.thelook_ecommerce.products;
  
 # Mostra o valor mínimo do item da coluna "retail_price"
 
------------------------------------

select
  min(retail_price) as PRECO_MINIMO_VAREJO,
  max(retail_price) as PRECO_MAXIMO_VAREJO,
from
  bigquery-public-data.thelook_ecommerce.products;
  
------------------------------------

select
  min(retail_price) as PRECO_MINIMO_VAREJO,
  max(retail_price) as PRECO_MAXIMO_VAREJO,
  dc.name
from
  bigquery-public-data.thelook_ecommerce.products as p
join
  bigquery-public-data.thelook_ecommerce.distribution_centers as dc on p.distribution_center_id = dc.id
group by name
order by 2;

------------------------------------

#### Agrupar preço máximo e mínimo por centro de distribuition

select
  round(max(retail_price), 2) as PRECO_MAXIMO_VAREJO,
  round(min(retail_price), 2) as PRECO_MINIMO_VAREJO,
  dc.name
from
  bigquery-public-data.thelook_ecommerce.products as p
join
  bigquery-public-data.thelook_ecommerce.distribution_centers as dc on p.distribution_center_id = dc.id
group by name
order by 2;

-------------------------------------

#### Cadastro do usuário mais recente e mais antigo.

select
  max(created_at) as UltimoCad,
  min(created_at) as PrimeiroCad,
from
  bigquery-public-data.thelook_ecommerce.users;
  
----------------------------------------------
#### FUNÇÃO EVERAGE(Média) / SUM(soma) ####

-- Somar uma coluna filtrando por compra finalizada.

select
  round(sum(sale_price), 2) as TotalVendas,
from
  bigquery-public-data.thelook_ecommerce.order_items
where
  status = 'Complete';
 
-----------------------------------------------

-- Somar uma coluna filtrando por compra finalizada e agrupando e ordenando por mês.

select
	round(sum(sale_price), 2) as TotalVendas,
	format_date('%Y-%m', created_at) as mes,
from
	bigquery-public-data.thelook_ecommerce.order_items
where
	status = 'Complete'
group by Mes
order by Mes desc;

-------------------------------------------------

#### COMANDO COUNT ####

select
  count(users) as QtdadeUsers,
from
  bigquery-public-data.thelook_ecommerce.users
where
  country = 'Brasil'
  
--------------------------------------------------
  
#### COMANDO COUNT USANDO IF ####

select
  count(if(country = 'Brasil', 1, 0)) as QtdadeUsers,
from
  bigquery-public-data.thelook_ecommerce.users;
  
# 1 = VERDADE, 0 = FALSE. Se 1 = True, soma, se não = 0
  
--------------------------------------------------

select
	count(case when country = 'Brasil' then id end) as QtdadeUsers,
from
	bigquery-public-data.thelook_ecommerce.users;

--------------------------------------------------

#### FUNÇÃO AVG (AVERAGE(MÉDIA)) ####

select
  round(avg(sale_price), 2) as PrecoMedio,
from
  bigquery-public-data.thelook_ecommerce.order_items
  
# fez a média de valores da coluna "sale_price".

---------------------------------------------------

select
  round(avg(sale_price), 2) as PrecoMedioMes,
  format_date('%Y-%m', created_at) as Mes
from
  bigquery-public-data.thelook_ecommerce.order_items
where status = 'Complete'
  group by Mes
  order by Mes;

----------------------------------------------------

#### EXERCÍCIOS MÓDULO 6 ####

1) Retorne em uma só consulta os valores de média, máximo, mínimo, contagem e
soma do campo “attendance” da tabela “schedules”, dataset “baseball”, mesmo
que a contagem e a soma de torcedores nos estádios não tenham significado
para análise de negócio.

select
	round(avg(attendance), 2) as MEDIA,
  max(attendance) as MAXIMO,
  min(attendance) as MINIMO,
  count(attendance) as CONTAGEM,
  sum(attendance) as SOMA,
from
	bigquery-public-data.baseball.schedules
where
	status = 'closed';

2) No mesmo dataset e tabela do exercício anterior, retornar a quantidade de jogos
disputados por cada time em casa por ano e também a soma de minutos jogados
em casa por ano. Ordenar de forma decrescente pelo ano e depois crescente
pelo nome do time.

select
	count(gameId) as Jogos,
	sum(duration_minutes) as SomaMinutos,
	homeTeamName as TimeCasa,
	year as Ano,
from
	bigquery-public-data.baseball.schedules
where
	status = 'closed'
group by 
	TimeCasa, Ano
order by
	Ano desc, TimeCasa;

3) No dataset “austin_bikeshare”, descubra qual a quantidade de viagens
realizadas em 2017 com duração de 30 minutos ou mais, somente de estações
(tanto de partida quanto de chegada) que estão atualmente ativas.

select
  count(trip_id) as viagens
from
	bigquery-public-data.austin_bikeshare.bikeshare_trips as t
join
	bigquery-public-data.austin_bikeshare.bikeshare_stations as si on t.start_station_id = si.station_id
join
	bigquery-public-data.austin_bikeshare.bikeshare_stations as sf on t.end_station_id = cast(sf.station_id as string)
where
	extract(year from start_time) = 2017 and duration_minutes >= 30 and si.status = "active" and sf.status = "active";

4) No mesmo dataset anterior, calcule a média de duração das viagens por tipo de
cliente (“subscriber_type”) por ano.

select
  round(avg(duration_minutes),2) as MediaTempoViagem,
  subscriber_type as TipoCliente, # 2
  extract(year from start_time) as Ano, # 3
from
  bigquery-public-data.austin_bikeshare.bikeshare_trips
group by 2, 3 # ou group by TipoCliente, Ano
order by Ano;

#### FUNÇÕES ABS(Absoluto), RAND(Aleatória), SQRT(Raiz Quadrada), POW(potenciação)
#### LOG, ROUND(Arredondamento), MOD ####

#### ABS(Absoluto) ####

--> Transforma número negativo em positivo.

select
	100,
	-25,
abs(100) as Teste_1,
abs(-25) as Teste_2;

#### RAND(Randômico) ####

--> Gera números aleatórios entre 0 e 1.

select
	rand() as Teste_1,
	5 * rand() as Teste_2,
	1000 * rand() as Teste_3;
	
	--------------------
	
select
	id,
	email,
	rand() as Randomico,
from
	bigquery-public-data.thelook_ecommerce.users
limit 20;
	
	--------------------
	
select
	id,
	email,
	rand() as Randomico,
from
	bigquery-public-data.thelook_ecommerce.users
where
	email is not null
order by Randomico
limit 10;

#### SQRT(Rais Quadrada) ####

select
	sqrt(9),
	sqrt(81),
	sqrt(0);

#### POW(Potenciação) ####

select
	pow(3, 2);
	
#### LOG(Logaritmo) ####

select
	log(49, 7);

--> Qual número levando a 7 que obtem o resultado 49? Resp.: 2  --> 7 elevado a 2 = 49
	
	
#### ROUND(Arredondamento) ####

select
	round(1.64, 1),
	round(1.65, 1),
	round(1.66, 1),
	round(23.5676665656, 2),
	round(52.45815180, 3),
	round(numeric '1.64', 1),
	round(numeric '1.65', 1);
	
	-----------------
	
select
	avg(retail_price),
	round(avg(retail_price), 2),
	round(avg(retail_price), 0),
from
	bigquery-public-data.thelook_ecommerce.products;
	
#### MOD(Resto da divisão) ####

select
	mod(4, 2), #--> Resto da divisão = 0
	mod(5, 2), #--> Resto da divisão = 1
	
	
/* Ache o conjunto de dados público do BigQuery “san_francisco_trees”, tabela “street_trees”. Essa tabela traz
informações de várias árvores na cidade de São Francisco, nos EUA. Retorne uma amostra de 100 árvores, sendo 50 da
espécie “Persea americana” e 50 da espécie “Magnolia grandiflora”. Precisa retornar essas amostras na MESMA consulta.
Pesquise como fazer isso.
DICA: pesquisar sobre WITH e sobre UNION ALL (esses dois comandos também serão explicados mais pra frente, já é
uma antecipação de conhecimento). */

with Persea as (
  select
    tree_id as IdArvores,
    species as Especies,
  from
    bigquery-public-data.san_francisco_trees.street_trees
  where
    species like '%Persea americana%'
  order by
    tree_id
  limit 50),

  Magnolia as (
  select
    tree_id as IdArvores,
    species as Especies,
  from
    bigquery-public-data.san_francisco_trees.street_trees
  where species like '%Magnolia grandiflora%'
  order by
    tree_id
  limit 50)

select
  *
from Persea

union all

select
  *
from Magnolia;


#### FUNÇÃO "CONCAT" (concatenação) ####

select
	'Hello',
	'Word',
concat('Hello', 'Word'),
concat('Hello', ' ', 'Word');

	-------------------------------
	
select
  -- first_name,
  -- last_name,
  concat(first_name, ' ', last_name)
from
  bigquery-public-data.thelook_ecommerce.users
limit 4;

	--------------------------------
	
select
	o.order_id,
	concat('Quantidade total de itens no pedido: ', avg(o.num_of_item), ' - ', 'Receita total do pedido: ', round(sum(sale_price), 2)) as detalhe
from
	bigquery-public-data.thelook_ecommerce.orders as o
join
	bigquery-public-data.thelook_ecommerce.order_items as oi on o.order_id = oi.order_id
group by
	o.order_id
order by
	o.order_id;


#### FUNÇÃO "STARTS_WITH" (Começa com) ####

select
	starts_with('Data Science', 'Data'), #--> Data Science começa com "Data"? True
	starts_with('Data Science', 'D'), #--> Data Science começa com "D"? True
	starts_with('Data Science', 'd'), #--> Data Science começa com "d"? False
	starts_with('Data Science', 'Science'), #--> Data Science começa com "Scince"? False

	----------------------------------
	
select
  id,
  first_name,
from
	bigquery-public-data.thelook_ecommerce.users
where
  starts_with(first_name, 'Mi');

	------------------------------------
	
#### FUNÇÕES LOWER(Minísculo) e UPPER(Maiúsculo) ####

select
	upper(first_name),
from
	bigquery-public-data.thelook_ecommerce.users;
	
	------------------------------------
	
select
	lower(first_name),
from
	bigquery-public-data.thelook_ecommerce.users;
	
	-----------------------------------

select
  upper(concat(first_name, ' ', last_name)),
from
  bigquery-public-data.thelook_ecommerce.users
where
  starts_with(first_name, 'Ni')
order by
  first_name;
  
  ------------------------------------
  
select
	distinct repo_name, 
from
	bigquery-public-data.github_repos.sample_repos
where
	lower(repo_name) like '%python%';
	
# --> Tranforma a palavra "python" em minúcula e trás independente se for minúscula ou maiúscula.
	
	-----------------------------------
	
select
	distinct repo_name, 
from
	bigquery-public-data.github_repos.sample_repos
where
	upper(repo_name) like '%python%';
	
# --> Tranforma a palavra "python" em maiúscula e trás independente se for minúscula ou maiúscula.

	------------------------------------
	
#### FUNÇÃO "INITCAP"(Transforma somente a primeira letra em maiúscula) ####

select
  id,
  first_name,
  last_name,
  concat(concat(first_name, ' ', last_name)) as NomeConcat,
  lower(concat(first_name, ' ', last_name)) as NomeLower,
  upper(concat(first_name, ' ', last_name)) as NomeUpper,
  initcap(concat(first_name, ' ', last_name)) as NomeInitCap,
from
  bigquery-public-data.thelook_ecommerce.users;
  
  -------------------------------------------
  
select
  -- display_name,
  initcap(display_name) as nome,
from
  bigquery-public-data.stackoverflow.users
limit 50;

	---------------------------------------
  
#### FUNÇÃO "SPLIT"(Separa as palavras) ####

select	
split('Creio que hoje vai chover e fazer calor', ' ') as Palavras;

	---------------------------------------
	
select	
split('Hoje, chove e fazer calor', ' ') as Palavras;

	----------------------------------------
	
select	
split('Hoje, chove e fazer calor', ' ')[1] as Palavras;

# --> Printa a palavra que está no índice 1 que é "chove".

	-----------------------------------------
	
select	
split('Hoje, chove e fazer calor', ' ')[ordinal(1)] as Palavra1,
split('Hoje, chove e fazer calor', ' ')[ordinal(2)] as Palavra2,
split('Hoje, chove e fazer calor', ' ')[ordinal(3)] as Palavra3;

	-----------------------------------------
	
select	
split('Hoje, chove e fazer calor', ' ')[ordinal(1)] as Palavra1,
split('Hoje, chove e fazer calor', ' ')[ordinal(2)] as Palavra2,
split('Hoje, chove e fazer calor', ' ')[ordinal(3)] as Palavra3,
split('Hoje, chove e fazer calor', ' ')[0] as P0,
split('Hoje, chove e fazer calor', ' ')[1] as P1,
split('Hoje, chove e fazer calor', ' ')[2] as P2;
	
	------------------------------------------
	
/* Exercício: Coletar todos domínios que estão cadastrados na base. */

select
  split(email, '@')[ordinal(2)] as Dominio,
from
  bigquery-public-data.thelook_ecommerce.users;

	-------------------------------------------
	
select
  distinct split(email, '@')[ordinal(2)] as Dominio,
from
  bigquery-public-data.thelook_ecommerce.users;
  
	-------------------------------------------
	
#### FUNÇÃO "TRIM"(Remove uma palavra do texto) ####

select
	trim('CPF: 256.844.808-37', 'CPF:');
	
# --> a saída será apenas o CPF = 256.844.808-37

	------------------------------------------
select
	ltrim('CPF: 256.844.808-37', 'CPF:');
	
# --> "ltrim" = left trim --> Remove a esquerda
# --> "rtrim" = right trim --> Remove a direita

	------------------------------------------

select
	ltrim('CPF: 256.844.808-37', 'CPF:');

# --> "rtrim" = right trim --> Remove a direita

	------------------------------------------

select
	trim('Dia: 29-09-2023 Hoje', 'Dia: '), # --> Remove a palavra "Dia".
	ltrim('Dia: 29-09-2023 Hoje', 'Dia: '), # --> Remove a palavra "Dia".
	rtrim('Dia: 29-09-2023 Hoje', 'Hoje: '); # --> Remove a palavra "Hoje".
	
	------------------------------------------

select
	trim('              São Paulo              ', ' ') as Cidade, # --> Remove os espaços a esquerda e direita.
	ltrim('****(14)3223-6789', '*') as TelFixo, # --> Remove os "*" a esquerda.
	rtrim('(14)98523-4567*******', '*') as TelMovel; # --> Remove os "*" a direita.
	
	------------------------------------------

#### FUNÇÃO "REPLACE"(Renomeia) ####

select
  name as OldName,
  replace(name, 'Port Authority of New York/New Jersey NY/NJ', 'New York NY') as NewName,
from
  bigquery-public-data.thelook_ecommerce.distribution_centers;
  
# --> Substituio o texto "Port Authority of New York/New Jersey NY/NJ" por "New York NY".

	--------------------------------------------
	
select
  name as OldName,
  replace(replace(name, 'Chicago IL', 'Chicago'), 'Chicago', 'CH IL') as NewName, # --> Um "replace" dentro de outro "replace".
from
  bigquery-public-data.thelook_ecommerce.distribution_centers
limit 5;

	--------------------------------------------
	
#### 	EXERCÍCIOS MÓDULO 8 ####

/* 1) Ache a tabela “users” no dataset “thelook_ecommerce”, no projeto de dados públicos do BigQuery.
Traga como resultado um único campo distinto com as informações de forma organizada dos campos
street_address + city + state + country + postal_code. */

select distinct
  concat('Endereço: ', street_address, '  -  Cidade: ', city, '  -  Estado: ', state, '  -  CEP: ', postal_code, '  -  País: ', country) as Endereco,
from
  bigquery-public-data.thelook_ecommerce.users
limit 50;

/* 2) Ache a tabela “top_terms” no dataset “google_trends”, e descubra os termos, suas posições
no rank e áreas de pesquisa para os termos começados com “N” no dia 2023-04-30. Obs.: não se
esqueça de colocar essa restrição de data no where, pois a tabela é grande e particionada
(processa somente a data que você colocar). Ordene por rank. */

select
  term,
  rank,
  dma_name,
from
  bigquery-public-data.google_trends.top_terms
where
  starts_with(term, 'N') and date(week) = '2023-04-30'
order by
  rank desc;

/* 3) Ache a tabela “stations” do dataset “new_york_subway” e substitua no campo “station_name”, a
palavra “St” por “Street” nos casos em que o final do nome da estação termine em “St” e “Av” por “Avenue” nos
casos em que o final do nome da estação termine em “Av”. Traga como resultado somente o campo “station_name” de
forma distinta e restringindo apenas as linhas que tenham “St” ou “Av” no nome. */

select distinct
	case
		when station_name like '%St' then replace(station_name, 'St', 'Street')
		when station_name like '%Av' then replace(station_name, 'Av', 'Avenue')
	end as station_new_name
from
	bigquery-public-data.new_york_subway.stations
where
	station_name like '%St' or station_name like '%Av';

/* 4) [DESAFIO] No mesmo dataset do item anterior e tabela “stop_times”, extraia somente o nome do dia da
semana do campo “trip_id”, considerando somente sábado e domingo como resposta (utilize como restrição no
where, usando lower e upper também). Traga também o “trip_id” no select. */

select
  trip_id,
  case
    when
		split(trip_id, '-')[2] = 'SI017'
    then
		split(trip_id, '-')[3]
	else
		split(trip_id, '-')[2]
  end as DiaSemana,
from
  bigquery-public-data.new_york_subway.stop_times
where
  lower(trip_id) like '%saturday%' or upper(trip_id) like '%SUNDAY%';
  
#### FUNÇÕES COM DATAS ####

select
	current_date() as Data1,
	current_timestamp() as Data2,
	current_datetime() as Data3,
	current_datetime('America/Sao_Paulo') as Data4,
	current_datetime('UTC-3') as Data5;
	
	------------------------------------
	
select
  date(2023, 10, 02) as ex1,
  date '2023-10-02' as ex2,
  datetime(2023, 10, 02, 19, 45, 00) as ex3,
  datetime '2023-10-02 19:45:00' as ex4,
  current_timestamp() as ex5,
  datetime(current_timestamp()) as ex6,
  datetime(current_date()) as ex7;
  
  --------------------------------------

select
  timestamp('2023-10-02 15:31:00') as ex1,
  timestamp('2023-10-02 15:31:00 America/Sao_Paulo') as ex2,
  timestamp('2023-10-02 15:31:00', 'America/Sao_Paulo') as ex3,
  timestamp(current_datetime) as ex4,
  timestamp(current_date) as ex5;
  
  --------------------------------------
  
  
 #### FUNÇÃO "EXTRACT" ####
 
 select
	current_date() as ex1,
	extract(mouth from current_date) as Mes,
	extract(dayofyear from current_date) as DiaDoAno;
	
	-----------------------------------
	
select
	current_timestamp as ex2,
	extract(hour from current_timestamp) as Hora,
	
	-----------------------------------
	
select
	current_datetime('America/Sao_Paulo') as Hora1,
	extract(hour from current_datetime('America/Sao_Paulo')) as Hora2,
	
	-----------------------------------
	
select
	count(order_id) as QtdadePedidos,
	extract(quarter from created_at) as Trimestre,
from
	bigquery-public-data.thelook_ecommerce.orders
where
	date(created_at) between '2022-01-01' and '2022-12-31'
group by
	2
order by
	2;
	
	-----------------------------------
	
select
	current_date as T1,
	date_add(current_date, interval 10 day) as T2,
	date_add(current_date, interval 3 month) as T3,
	current_timestamp() as T4,
	timestamp_add(current_timestamp, interval 2 hour) as T5;
	
	
# --> "DATE_ADD" adiciona dias.

	------------------------------------
	
select
	current_date as T1,
	date_sub(current_date, interval 10 day) as T2,
	date_sub(current_date, interval 3 month) as T3,
	current_timestamp() as T4,
	timestamp_sub(current_timestamp, interval 2 hour) as T5;
	
# --> "DATE_SUB" subtrai dias.
	
	-----------------------------------
	
select
	*
from
	bigquery-public-data.thelook_ecommerce.orders
where
	date(created_at) = current_date() - interval 5 day;
	
	--------------------------------------
	
select
	*
from
	bigquery-public-data.thelook_ecommerce.orders
where
	date(created_at) = current_date() - interval 5 day
order by
  created_at desc;
  
# --> Mostra tudo da tabela "order" desconsiderando o últimos 5 dias atuais

  ------------------------------------------
  
select
	*
from
	bigquery-public-data.thelook_ecommerce.orders
where
	date(created_at) = date_sub(current_date(), interval 5 day);
	
	----------------------------------------
	
/* Exibir a quantidade de pedidos feitos com situação "Complete" nos últimos três dias no banco thelook_ecommerce
	e ordenar por data */

select
  date(created_at) as DataPedido,
  sum(num_of_item) as QtdeItensPedido,
from
  bigquery-public-data.thelook_ecommerce.orders
where
  date(created_at) >= date_sub(current_date, interval 3 day) and status = 'Complete'
group by
  DataPedido
order by
  DataPedido desc;
  
  ----------------------------------------------
  
select
  date(created_at) as DataPedido,
  sum(num_of_item) as QtdeItensPedido,
from
  bigquery-public-data.thelook_ecommerce.orders
where
	date(created_at) between date_sub(current_date, interval 5 day) and current_date
group by
  DataPedido
order by
  DataPedido;
  
	---------------------------------------------------
  
select
	date_diff('2022-10-05', '2022-10-01', day) as ex1,
	datetime_diff('2022-10-05T21:00:00', '2022-10-05T14:00:00', hour) as ex2,
	timestamp_diff('2022-10-05 21:30:00', '2022-10-05 21:00:00', minute) as ex3;
	
	-------------------------------------------------

select
	u.id,
	min(timestamp_diff(o.created_at, u.created_at, day)) as DiaPrimeiraCompra,
from
	bigquery-public-data.thelook_ecommerce.orders o
join
	bigquery-public-data.thelook_ecommerce.users u on u.id = o.user_id
group by
	1
order by
	2 desc;
	
	-------------------------------------------

with dias as (
	select
		u.id,
		min(timestamp_diff(o.created_at, u.created_at, day)) as DiasPrimeiraCompra,
	from
		bigquery-public-data.thelook_ecommerce.orders o
	join
		bigquery-public-data.thelook_ecommerce.users u on u.id = o.user_id
	group by
		1
	order by
		2 desc
)

select
	avg(DiasPrimeiraCompra) as MediaDiasPrimeiraCompra
from
	dias;
	
	--------------------------------------------
	
#### FUNÇÕES "FORMAT_DATE", "FORMAT_DATETIME", "FORMAT_TIMESTAMP" ####

select
  format_date('%Y - %m', current_date) as AnoMes,
  format_timestamp('%H - %M', current_timestamp) as HoraMinuto,
  format_timestamp('%R', current_timestamp) as Hora,
  
  -----------------------------------------------

select
	count(id) as Users,
	format_timestamp('%Y - %m', created_at) as MesCadastro,
from
	bigquery-public-data.thelook_ecommerce.users
group by
	2
order by
	2 desc;
	
	--------------------------------------------
	
/* 1) Procure o dataset “thelook_ecommerce”. Calcule o tempo em dias da data de cadastro até a última compra de cada usuário. */

select
  u.id,
  max(timestamp_diff(o.created_at, u.created_at, day)) as TempoAteUltimaCompra,
from
  bigquery-public-data.thelook_ecommerce.users as u
join
  bigquery-public-data.thelook_ecommerce.orders as o on u.id = o.user_id
group by
	1
order by
	2 desc;

/* 2) Na mesma tabela, calcule o tempo em dias entre a primeira e a última compra de cada usuário. */

select
  user_id,
  timestamp_diff(max(created_at), min(created_at, day) as TempoEntreCompras,
from
  bigquery-public-data.thelook_ecommerce.orders;
group by
	1
order by
	2;

/* 3) No mesmo dataset, e tabela de eventos, traga a quantidade de registros para cada usuário entre 06 de maio
de 2023 menos 73 dias e 09 de maio de 2023, nos eventos de carrinho e compra. Ordene por usuário e tipo do evento. */

select
	user_id,
	event_type,
	count(distinct id) as Qtdade,
from
	bigquery-public-data.thelook_ecommerce.events
where
	event_type in ('cart', 'purchase')
and
	date(created_at) between date_sub('2023-05-06', interval 73 day)
and
	'2023-05-09'
and
	user_id is not null
group by
	1, 2
order by
	1, 2;

/* 4) Ache o dataset “catalonian_mobile_coverage” e calcule a quantidade de sinais 4G recebidos no mês de março de 2016. */

select
  count(net),
from
  bigquery-public-data.catalonian_mobile_coverage.mobile_data_2015_2017
where
  net like '4G' and date(date) between '2016-03-01' and '2016-03-31';


select
  net as SINAL,
  count(*) as QTDADE_SINAL,
from
  bigquery-public-data.catalonian_mobile_coverage.mobile_data_2015_2017
where net is not null
  group by net;
  
  
#### PONTOS GEOGRÁFICOS ####

select
	# INFORM. ESTAÇÕES DE PARTIDA
	start_station_latitude,
	start_station_longitude,
	start_station_geom,
	st_geogpoint(start_station_longitude, start_station_latitude) as PontoGeograficoInicial,
	
	# INFORM. ESTAÇÕES DE CHEGADA
	end_station_latitude,
	end_station_longitude
	end_station_geom,
	st_geogpoint(end_station_longitude, end_station_latitude) as PontoGeograficoFinal,
	
	# DISTÂNCIA E VELOCIDADE MÉDIA (M/S)
	round(st_distance(start_station_geom, end_station_geom), 0) as DistanciaMetros,
	round(st_distance(start_station_geom, end_station_geom) / duration_sec, 1) as VelocidadeMedia,
	
	# LONGITUDE X LATITUDE
	st_x(start_station_geom) as LONGITUDE,
	st_y(start_station_geom) as LATITUDE,
  
	# LINHA DIRECIONAL
	st_makeline(start_station_geom, end_station_geom) as ROTA

from
	bigquery-public-data.san_francisco_bikeshare.bikeshare_trips
where
	start_station_latitude is not null
and	start_station_longitude is not null
and	end_station_longitude is not null
and end_station_latitude is not null
and round(st_distance(start_station_geom, end_station_geom), 0) > 0
order by
	rand()
limit 100;
	

#### VISUALIZANDO ROTA NO LOOKER STUDIO DO BIG QUERY ####

select
	trip_id,
	st_makeline(start_station_geom, end_station_geom) as ROTA

from
	bigquery-public-data.san_francisco_bikeshare.bikeshare_trips
where
	start_station_latitude is not null
and	start_station_longitude is not null
and	end_station_longitude is not null
and end_station_latitude is not null
and round(st_distance(start_station_geom, end_station_geom), 0) > 0
order by
	rand()
limit 10;
	
	
	#### EXERCÍCIOS MÓDULO 10 ####
	
/* 1) Ache o dataset “austin_crime” no conjunto de dados públicos do BigQuery.
Pegue 10 incidentes aleatórios com latitude e longitude não nulas. Crie os pontos
geográficos. Vá até o Google Maps e selecione uma coordenada qualquer na
cidade de Austin, EUA (pesquise como fazer) e calcule a distância (em km) entre
cada ponto desses incidentes à coordenada escolhida. Crie também as rotas de
cada incidente à coordenada. */

select
  latitude as Latitude,
  longitude as Longitude,
  st_geogpoint(longitude, latitude) as PontoGeografico,
  st_geogpoint(-97.7455835, 30.2677174) as LavacaPlaza_Austin_TX,
  round(st_distance(st_geogpoint(longitude, latitude), st_geogpoint(-97.7455835, 30.2677174)) / 1000, 2) as Distancia,
  st_makeline(st_geogpoint(longitude, latitude), st_geogpoint(-97.7455835, 30.2677174)) as Rota,
from
  bigquery-public-data.austin_crime.crime
where latitude is not null and longitude is not null
  order by
    rand()
limit 10;



/* 2) Calcule a mínima e a máxima distância do resultado da query acima. */

with Dist as (

  select
    latitude as Latitude,
    longitude as Longitude,
    st_geogpoint(longitude, latitude) as PontoGeografico,
    st_geogpoint(-97.7455835, 30.2677174) as LavacaPlaza_Austin_TX,
    round(st_distance(st_geogpoint(longitude, latitude), st_geogpoint(-97.7455835, 30.2677174)) / 1000, 2) as Distancia,
    st_makeline(st_geogpoint(longitude, latitude), st_geogpoint(-97.7455835, 30.2677174)) as Rota,
  from
    bigquery-public-data.austin_crime.crime
  where latitude is not null and longitude is not null
    order by
      rand()
  limit 10
)

select
  min(Distancia) as Minimo,
  max(Distancia) as Maximo,
from
  Dist;

 ### FUNÇÃO "JOIN" ####
 
 # INNER JOIN
 
 select distinct
  a.user_id as UserIDAcessos,
  c.user_id as UserIDCompras,
  a.name as Nome,
from
  estudo-sql-ds.Estudo_JOIN.acessos as a
inner join
  estudo-sql-ds.Estudo_JOIN.compras as c on a.user_id = c.user_id;
  
 -- Observação: INNER JOIN tem a mesma função que o JOIN --
 
 
 #### UNINDO TRÊS TABELAS ####
 
 select distinct
  a.name as TabelaAcessos,
  c.name as TabelaCompras,
  u.name as TabelaUsuarios,
from
  estudo-sql-ds.Estudo_JOIN.acessos as a
join
  estudo-sql-ds.Estudo_JOIN.compras as c on a.name = c.name
join
  estudo-sql-ds.Estudo_JOIN.acessos as u on a.name = u.name;
  
	------------------------------------
	
#### LEFT JOIN ####

select
  a.user_id as IDUserAcessos,
  c.user_id as IDUserCompras,
  revenue as Receita,
from
  estudo-sql-ds.Estudo_JOIN.acessos as a
left join
  estudo-sql-ds.Estudo_JOIN.compras as c on a.user_id = c.user_id;
  
  
--Obs.: Usando "left join", será priorizada a tabela da esquerda. No exemplo, será a tabela "acessos".
  
  --------------------------------------
  
#### RIGHT JOIN ####

select
  a.user_id as IDUserAcessos,
  c.user_id as IDUserCompras,
  revenue as Receita,
from
  estudo-sql-ds.Estudo_JOIN.acessos as a
right join
  estudo-sql-ds.Estudo_JOIN.compras as c on a.user_id = c.user_id;
  
--Obs.: Usando "right join", será priorizada a tabela da direita. No exemplo, será a tabela "compras".


  
#### FULL JOIN ####

select
  a.user_id as IDUserAcessos,
  a.name as NomeAcessos,
  c.user_id as IDUserCompras,
  c.name as NomeCompras,
  revenue as Receita,
from
  estudo-sql-ds.Estudo_JOIN.acessos as a
full join
  estudo-sql-ds.Estudo_JOIN.compras as c on a.user_id = c.user_id;
  
--Obs.: Usando "full join", não priorizará a tabela da esquerda ou da direita. Pega ambas tabelas com a mesma importância.

	-------------------------
	
select
  a.user_id as IDUserAcessos,
  a.name as NomeAcessos,
  c.user_id as IDUserCompras,
  c.name as NomeCompras,
  revenue as Receita,
from
  estudo-sql-ds.Estudo_JOIN.acessos as a
full join
  estudo-sql-ds.Estudo_JOIN.compras as c on a.user_id = c.user_id
where
  a.user_id is null or c.user_id is null;

	---------------------------
	
select
	a.user-id as user_id_a,
	a.name as name_a,
	c.user_id as user_id_c,
	c.name as name_c,
	c.revenue,
	u.id as user_id_u,
	u.name as name_u,
from
	estudo-sql-ds.Estudo_JOIN.acessos as a
full join
	estudo-sql-ds.Estudo_JOIN.compras as c on a.user_id = c.user_id
full join
	estudo-sql-ds.Estudo_JOIN.usuarios as u on u.id = coalesce(a.user_id, c.user_id);
	
	---------------------------
	
select
	a.user-id as user_id_a,
	a.name as name_a,
	c.user_id as user_id_c,
	c.name as name_c,
	c.revenue,
	u.id as user_id_u,
	u.name as name_u,
from
	estudo-sql-ds.Estudo_JOIN.acessos as a
full join
	estudo-sql-ds.Estudo_JOIN.compras as c on a.user_id = c.user_id
full join
	estudo-sql-ds.Estudo_JOIN.usuarios as u on u.id = coalesce(a.user_id, c.user_id)
where
	coalesce(a.user_id, c.user_id) is null;
	
	-------------------------------

/* 1) Ache o dataset “thelook_ecommerce” nos dados públicos do BigQuery. Traga os usuários
que não tem compra em dezembro de 2022. */


select distinct
	u.id
from
	bigquery-public-data.thelook_ecommerce.users as u
left join
	bigquery-public-data.thelook_ecommerce.orders as o on u.id = o.user_id and date (o.created_at) between '2022-12-01' and '2022-12-31'
where
	o.user_id is null;
	

/* 2) No mesmo dataset, traga informações resumidas sobre os usuários (de todos, tendo ou não
compras). Id do usuário, quantidade de compras realizadas, quantidade de itens comprados, ticket médio,
quantidade de produtos distintos comprados, centro de distribuições dos quais o usuário recebeu
produtos, quantidade de criações de carrinho. */

select distinct
	u.id,
	count(distinct o.order_id) as ComprasRealizadas,
	count(distinct oi.id) as ItensComprados,
	case
		when count(distinct o.order_id) > 0 then round(sum(sale_price) / count(distinct o.order_id), 2)
		else 0
	end as TicketMedio,
	count(distinct p.id) as ProdutosDistintos,
	count(distinct d.id) as CentrosDistribuicao,
	count(distinct e.id) as EventosCarrinho,
from bigquery-public-data.thelook_ecommerce.users as u
left join bigquery-public-data.thelook_ecommerce.orders as o on u.id = o.user_id
left join bigquery-public-data.thelook_ecommerce.order_items as oi on o.order_id = oi.order_id
left join bigquery-public-data.thelook_ecommerce.products as p on p.id = oi.product_id
left join bigquery-public-data.thelook_ecommerce.distribution_centers as d on d.id = p.distribuition_center_id
left join bigquery-public-data.thelook_ecommerce.events as e on e.user_id = u.id and event_type = 'cart'
group by u.id
order by id;

	#### SUBQUERY (CONSULTA DENTRO DE OUTRA CONSULTA) ####
	
	#### EXEMPLOS DE SUBQUERY COM COLUNAS ####
	
-- SOMANDO A QUANTIDADE DE COMPRAS POR USUÁRIO --
	
select
	u.id,
	u.name,	
	(
	select
		count(id),
		from estudo-sql-ds.relacionamentos.compras as c
			where c.user_id = u.id
	) as NumeroCompras
from
	estudo-sql-ds.relacionamentos.usuarios as u;
	
	---------------------------
	
	#### TRAZER A QUANTIDADE DE ACESSOS POR USUÁRIO ####
	
select
	(select
		count(id)
	from
		estudo-sql-ds.relacionamentos.acessos as a
	where
		a.user_id = u.id
	)
from
	estudo-sql-ds.relacionamentos.usuarios as u;

	-----------------------------
	
-- CALCULANDO A MÉDIA DE ACESSOS POR USUÁRIO --

select
	avg((
	select
		count(id),
		from estudo-sql-ds.relacionamentos.acessos as c
			where c.user_id = u.id
	)) as MediaAcessos
from
	estudo-sql-ds.relacionamentos.usuarios as u;
	
	--------------------------------
	
	#### EXEMPLOS DE SUBQUERY COM TABELAS ####

-- CONTAR A QUANTIDADE DE ACESSOS POR USUÁRIOS --	

select
  u.id as UserID,
  count(a.id) as QtdeAcessos,
from estudo-sql-ds.relacionamentos.usuarios as u
left join estudo-sql-ds.relacionamentos.acessos as a on u.id = a.user_id
group by u.id;
	---------------------------------------------------

-- CALCULANDO A MEDIA DE ACESSOS POR USUÁRIOS --

select
	avg(QtdeAcessos) as media_acessos,
from(
    select
		u.id as USerID,
		count(a.id) as QtdeAcessos,
	from estudo-sql-ds.relacionamentos.usuarios as u
	left join estudo-sql-ds.relacionamentos.acessos as a on u.id = a.user_id
	group by u.id);

	--------------------------------

# USUÁRIOS QUE TEM COMPRA ONLINE E ACESSOS #

select distinct
  a.user_id as UserID_A,
  c.user_id as UserID_C,
  a.name,
from estudo-sql-ds.relacionamentos.acessos as a
inner join estudo-sql-ds.relacionamentos.compras as c on a.user_id = c.user_id;

---------------------------------------------------------------------------------
# SOMENTE OS USUÁRIO QUE TEM ACESSO E NÃO TEM COMPRAS #

select distinct
  a.user_id as UserID_A,
  c.user_id as UserID_C,
  a.name,
  revenue,
from estudo-sql-ds.relacionamentos.acessos as a
left join estudo-sql-ds.relacionamentos.compras as c on a.user_id = c.user_id
where c.user_id is null;

----------------------------------------------------------------------------------
# USUÁRIOS SEM ACESSOS E SEM COMPRAS #

select
  a.user_id,
  c.user_id,
  c.name,
  c.revenue,
from estudo-sql-ds.relacionamentos.acessos as a
right join estudo-sql-ds.relacionamentos.compras as c on a.user_id = c.user_id
where a.user_id is null and revenue is null;

----------------------------------------------------------------------------
# COMPRA SÓ LOJA FÍSICA E SEM ACESSOS #

select distinct
	a.user_id as UserID_A,
	a.name as Name_A,
	c.user_id as UserID_C,
	c.name as Name_C,
	c.revenue,
from estudo-sql-ds.relacionamentos.acessos as a
full join estudo-sql-ds.relacionamentos.compras as c on a.user_id = c.user_id
where a.user_id is null;

	-----------------------------------------------

	#### SOMANDO O VALOR DOS PEDIDOS ####
	
select
  order_id,
  round(sum(sale_price), 2) as Receita,
from bigquery-public-data.thelook_ecommerce.order_items
group by order_id;

	------------------------------------------------

	#### CALCULANDO A MÉDIA DE VALOR POR PEDIDO POR USUÁRIO ####
	
select
  user_id,
  round(avg(Receita),2) as ValorMedio,
  from (
    select
      order_id,
      user_id,
      round(sum(sale_price), 2) as Receita,
      from bigquery-public-data.thelook_ecommerce.order_items
      group by order_id, user_id)
group by user_id;

	-------------------------------------------------
	
	#### SUBQUERY COMO FILTRO ####
	
	# CALCULANDO A QUANTIDADE DE COMPRAS POR USUÁRIO #
select
	u.id,
	u.name,
	(
		select
			count(c.id) as NumCompras
		from estudo-sql-ds.relacionamentos.compras as c
		where c.user_id = u.id
	) as NumeroCompras
from estudo-sql-ds.relacionamentos.usuarios as u
where (
	select
		count(c.id) as NumCompras
	from estudo-sql-ds.relacionamentos.compras as c
	where c.user_id = u.id
	) > 0;
	
	----------------------------------------------------
	
#### EXEMPLO DE UMA QUERY CONTENDO AS TRÊS SUBQUERY (COLUNA, TABELA, FILTRO) ####

select
	u.id,
	u.name,
	(
		select
			count(c.id) as Numero_Compras
		from estudo-sql-ds.relacionamentos.compras as c
		where c.user_id = u.id
	) as Num_Compras, acessos as Num_Acessos
from estudo-sql-ds.relacionamentos.usuarios as u
left join (
  select
    count(a.id) as Acessos,
    user_id,
  from studo-sql-ds.relacionamentos.acessos as a
  group by user_id
) as TabelaID on TabelaID.user_id = u.id
where (
	select
		count(c.id) as Num_Compras
	from estudo-sql-ds.relacionamentos.compras as c
	where c.user_id = u.id
	) > 0;
	
